# Graph Representation in C++ - Two Ways (G-2 Notes)

## Overview

This covers the fundamental ways to represent graphs in C++ programming, focusing on the two most common methods: Adjacency Matrix and Adjacency List.

## What is a Graph?

- A graph is a data structure consisting of:
    - **Vertices (Nodes)**: The entities in the graph
    - **Edges**: The connections between vertices
- Graphs can be:
    - **Directed**: Edges have direction (A → B)
    - **Undirected**: Edges have no direction (A ↔ B)
    - **Weighted**: Edges have associated weights/costs
    - **Unweighted**: All edges have equal importance

## Method 1: Adjacency Matrix Representation

### Concept

- Uses a 2D array/matrix to represent the graph
- If there are N vertices, we use an N×N matrix
- `matrix[i][j] = 1` if there's an edge from vertex i to vertex j
- `matrix[i][j] = 0` if there's no edge

### Implementation for Undirected Graph

```cpp
#include <iostream>
#include <vector>
using namespace std;

class GraphMatrix {
private:
    int numVertices;
    vector<vector<int>> adjMatrix;
    
public:
    // Constructor
    GraphMatrix(int vertices) {
        numVertices = vertices;
        adjMatrix.resize(vertices, vector<int>(vertices, 0));
    }
    
    // Add edge (undirected)
    void addEdge(int src, int dest) {
        adjMatrix[src][dest] = 1;
        adjMatrix[dest][src] = 1; // For undirected graph
    }
    
    // Display matrix
    void displayMatrix() {
        cout << "Adjacency Matrix:" << endl;
        for (int i = 0; i < numVertices; i++) {
            for (int j = 0; j < numVertices; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
    
    // Check if edge exists
    bool hasEdge(int src, int dest) {
        return adjMatrix[src][dest] == 1;
    }
};
```

### Implementation for Directed Graph

```cpp
class DirectedGraphMatrix {
private:
    int numVertices;
    vector<vector<int>> adjMatrix;
    
public:
    DirectedGraphMatrix(int vertices) {
        numVertices = vertices;
        adjMatrix.resize(vertices, vector<int>(vertices, 0));
    }
    
    // Add edge (directed)
    void addEdge(int src, int dest) {
        adjMatrix[src][dest] = 1; // Only one direction
    }
    
    void displayMatrix() {
        cout << "Directed Graph Adjacency Matrix:" << endl;
        for (int i = 0; i < numVertices; i++) {
            for (int j = 0; j < numVertices; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
};
```

### Advantages of Adjacency Matrix

- **Fast edge lookup**: O(1) time to check if edge exists
- **Simple implementation**: Easy to understand and code
- **Good for dense graphs**: When most vertices are connected
- **Matrix operations**: Easier for mathematical operations on graphs

### Disadvantages of Adjacency Matrix

- **Space complexity**: O(V²) - uses lot of memory even for sparse graphs
- **Adding vertices**: Difficult to add new vertices dynamically
- **Sparse graphs**: Wasteful for graphs with few edges

## Method 2: Adjacency List Representation

### Concept

- Uses an array of lists (or vectors in C++)
- Each index represents a vertex
- Each list contains all vertices adjacent to that vertex
- More memory efficient for sparse graphs

### Implementation for Undirected Graph

```cpp
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class GraphList {
private:
    int numVertices;
    vector<list<int>> adjList;
    
public:
    // Constructor
    GraphList(int vertices) {
        numVertices = vertices;
        adjList.resize(vertices);
    }
    
    // Add edge (undirected)
    void addEdge(int src, int dest) {
        adjList[src].push_back(dest);
        adjList[dest].push_back(src); // For undirected graph
    }
    
    // Display adjacency list
    void displayList() {
        cout << "Adjacency List:" << endl;
        for (int i = 0; i < numVertices; i++) {
            cout << i << " -> ";
            for (int neighbor : adjList[i]) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
    
    // Check if edge exists
    bool hasEdge(int src, int dest) {
        for (int neighbor : adjList[src]) {
            if (neighbor == dest) return true;
        }
        return false;
    }
};
```

### Implementation Using Vector of Vectors

```cpp
class GraphVector {
private:
    int numVertices;
    vector<vector<int>> adjList;
    
public:
    GraphVector(int vertices) {
        numVertices = vertices;
        adjList.resize(vertices);
    }
    
    void addEdge(int src, int dest) {
        adjList[src].push_back(dest);
        adjList[dest].push_back(src); // For undirected
    }
    
    void displayList() {
        for (int i = 0; i < numVertices; i++) {
            cout << i << " -> ";
            for (int j = 0; j < adjList[i].size(); j++) {
                cout << adjList[i][j] << " ";
            }
            cout << endl;
        }
    }
};
```

### Advantages of Adjacency List

- **Space efficient**: O(V + E) space complexity
- **Dynamic**: Easy to add vertices and edges
- **Sparse graphs**: Perfect for graphs with few edges
- **Iteration**: Easy to iterate through neighbors

### Disadvantages of Adjacency List

- **Edge lookup**: O(V) time to check if specific edge exists
- **More complex**: Slightly more complex implementation
- **Cache performance**: May have poor cache locality

## Time and Space Complexity Comparison

|Operation|Adjacency Matrix|Adjacency List|
|---|---|---|
|**Space**|O(V²)|O(V + E)|
|**Add Edge**|O(1)|O(1)|
|**Remove Edge**|O(1)|O(V)|
|**Check Edge**|O(1)|O(V)|
|**Find all neighbors**|O(V)|O(degree)|

Where:

- V = Number of vertices
- E = Number of edges
- degree = Number of neighbors of a vertex

## When to Use Which?

### Use Adjacency Matrix When:

- Graph is dense (many edges)
- Need frequent edge existence queries
- Performing matrix operations on graphs
- Graph size is small and fixed

### Use Adjacency List When:

- Graph is sparse (few edges)
- Need to frequently traverse neighbors
- Graph size can change dynamically
- Memory is a constraint

## Complete Example Program

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Example: Create a graph with 5 vertices
    int vertices = 5;
    
    // Using Adjacency Matrix
    cout << "=== ADJACENCY MATRIX ===" << endl;
    GraphMatrix gMatrix(vertices);
    gMatrix.addEdge(0, 1);
    gMatrix.addEdge(0, 4);
    gMatrix.addEdge(1, 2);
    gMatrix.addEdge(1, 3);
    gMatrix.addEdge(1, 4);
    gMatrix.addEdge(2, 3);
    gMatrix.addEdge(3, 4);
    
    gMatrix.displayMatrix();
    
    cout << "\n=== ADJACENCY LIST ===" << endl;
    GraphList gList(vertices);
    gList.addEdge(0, 1);
    gList.addEdge(0, 4);
    gList.addEdge(1, 2);
    gList.addEdge(1, 3);
    gList.addEdge(1, 4);
    gList.addEdge(2, 3);
    gList.addEdge(3, 4);
    
    gList.displayList();
    
    return 0;
}
```

## Key Takeaways

1. **Adjacency Matrix**: Best for dense graphs, O(1) edge queries, O(V²) space
2. **Adjacency List**: Best for sparse graphs, O(V+E) space, dynamic sizing
3. **Choice depends on**: Graph density, operations needed, memory constraints
4. **In competitive programming**: Adjacency list is more commonly used
5. **For algorithms like DFS/BFS**: Both work well, but adjacency list is preferred

## Common Mistakes to Avoid

- Forgetting to add reverse edges in undirected graphs
- Not handling 0-based vs 1-based indexing consistently
- Choosing wrong representation for the use case
- Not considering memory constraints for large graphs
- Forgetting to initialize the data structure properly

## Practice Problems

Try implementing:

1. Weighted graph representation
2. Graph input/output functions
3. Basic graph traversal (DFS/BFS) using both representations
4. Converting between adjacency matrix and adjacency listter
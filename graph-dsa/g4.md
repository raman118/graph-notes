# Connected Components in Graphs (G-4 Notes)

## What are Connected Components?

### Definition

A connected component in an undirected graph is a group of vertices such that within a group each vertex can be reached from another and no path exists between different groups.

In simpler terms:

- **Connected Component**: A maximal set of vertices where every vertex is reachable from every other vertex in the same component
- **Maximal**: You cannot add any more vertices to this set without breaking the connectivity property
- **No path exists between different components**: Vertices in different components are completely isolated from each other

### Visual Understanding

```
Graph with 3 Connected Components:

Component 1:     Component 2:     Component 3:
   1---2            5---6            9
   |   |            |               / \
   3---4            7              10--11

```

## Key Concepts

### Properties of Connected Components

1. **Within a component**: Every pair of vertices has at least one path connecting them
2. **Between components**: No path exists between vertices of different components
3. **Partitioning**: Connected components partition the graph into disjoint subsets
4. **Maximal subgraphs**: Each component is the largest possible connected subgraph

### Types of Connectivity

#### For Undirected Graphs

- **Connected**: If there's a path between every pair of vertices
- **Disconnected**: If the graph has more than one connected component

#### For Directed Graphs

- **Weakly Connected Component**: Ignoring edge directions, vertices are connected
- **Strongly Connected Component**: There's a directed path from every vertex to every other vertex

## Algorithm to Find Connected Components

### Approach Overview

We can use Depth First Search or Breadth First Search. We will be doing a series of rounds of DFS: The first round will start from first node and all the nodes in the first connected component will be traversed. Then we find the first unvisited node of the remaining nodes, and run DFS on it, thus finding a second connected component. And so on, until all nodes are visited.

### Step-by-Step Algorithm

1. **Initialize**: Create a visited array to track processed vertices
2. **Iterate**: Go through all vertices from 0 to n-1
3. **Check**: If a vertex is not visited, start a new DFS/BFS from it
4. **Traverse**: The DFS/BFS will visit all vertices in that connected component
5. **Mark**: All visited vertices belong to the same component
6. **Repeat**: Continue until all vertices are processed

### Time Complexity

The total asymptotic running time of this algorithm is O(n + m): this algorithm will not run on the same vertex twice, which means that each edge will be seen exactly two times (at one end and at the other end).

## Implementation in C++

### Method 1: Using DFS (Recursive)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class ConnectedComponents {
private:
    int n;                          // Number of vertices
    vector<vector<int>> adj;        // Adjacency list
    vector<bool> used;              // Visited array
    vector<int> comp;               // Current component vertices
    
public:
    ConnectedComponents(int vertices) {
        n = vertices;
        adj.resize(n);
        used.resize(n);
    }
    
    // Add edge to the graph
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);  // Undirected graph
    }
    
    // DFS to traverse one connected component
    void dfs(int v) {
        used[v] = true;
        comp.push_back(v);
        
        for (int u : adj[v]) {
            if (!used[u]) {
                dfs(u);
            }
        }
    }
    
    // Find and display all connected components
    void findComponents() {
        fill(used.begin(), used.end(), false);
        int componentCount = 0;
        
        for (int v = 0; v < n; ++v) {
            if (!used[v]) {
                comp.clear();
                dfs(v);
                
                componentCount++;
                cout << "Component " << componentCount << ": ";
                for (int u : comp) {
                    cout << u << " ";
                }
                cout << endl;
            }
        }
        
        cout << "Total Connected Components: " << componentCount << endl;
    }
    
    // Get number of connected components
    int countComponents() {
        fill(used.begin(), used.end(), false);
        int count = 0;
        
        for (int v = 0; v < n; ++v) {
            if (!used[v]) {
                comp.clear();
                dfs(v);
                count++;
            }
        }
        return count;
    }
};
```

### Method 2: Using DFS (Iterative - Stack)

```cpp
#include <stack>

class ConnectedComponentsIterative {
private:
    int n;
    vector<vector<int>> adj;
    vector<bool> used;
    vector<int> comp;
    
public:
    ConnectedComponentsIterative(int vertices) {
        n = vertices;
        adj.resize(n);
        used.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // Iterative DFS using stack
    void dfs(int v) {
        stack<int> st;
        st.push(v);
        
        while (!st.empty()) {
            int curr = st.top();
            st.pop();
            
            if (!used[curr]) {
                used[curr] = true;
                comp.push_back(curr);
                
                // Add neighbors to stack (in reverse order for consistent traversal)
                for (int i = adj[curr].size() - 1; i >= 0; i--) {
                    if (!used[adj[curr][i]]) {
                        st.push(adj[curr][i]);
                    }
                }
            }
        }
    }
    
    void findComponents() {
        fill(used.begin(), used.end(), false);
        int componentCount = 0;
        
        for (int v = 0; v < n; ++v) {
            if (!used[v]) {
                comp.clear();
                dfs(v);
                
                componentCount++;
                cout << "Component " << componentCount << ": ";
                for (int u : comp) {
                    cout << u << " ";
                }
                cout << endl;
            }
        }
    }
};
```

### Method 3: Using BFS (Queue)

```cpp
#include <queue>

class ConnectedComponentsBFS {
private:
    int n;
    vector<vector<int>> adj;
    vector<bool> used;
    vector<int> comp;
    
public:
    ConnectedComponentsBFS(int vertices) {
        n = vertices;
        adj.resize(n);
        used.resize(n);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // BFS to traverse one connected component
    void bfs(int start) {
        queue<int> q;
        q.push(start);
        used[start] = true;
        
        while (!q.empty()) {
            int v = q.front();
            q.pop();
            comp.push_back(v);
            
            for (int u : adj[v]) {
                if (!used[u]) {
                    used[u] = true;
                    q.push(u);
                }
            }
        }
    }
    
    void findComponents() {
        fill(used.begin(), used.end(), false);
        int componentCount = 0;
        
        for (int v = 0; v < n; ++v) {
            if (!used[v]) {
                comp.clear();
                bfs(v);
                
                componentCount++;
                cout << "Component " << componentCount << ": ";
                for (int u : comp) {
                    cout << u << " ";
                }
                cout << endl;
            }
        }
    }
};
```

## Complete Example Program

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // Create a graph with 7 vertices
    ConnectedComponents graph(7);
    
    // Add edges to create multiple components
    // Component 1: 0-1-2
    graph.addEdge(0, 1);
    graph.addEdge(1, 2);
    
    // Component 2: 3-4
    graph.addEdge(3, 4);
    
    // Component 3: 5-6
    graph.addEdge(5, 6);
    
    cout << "Finding Connected Components:" << endl;
    graph.findComponents();
    
    cout << "\nNumber of components: " << graph.countComponents() << endl;
    
    return 0;
}
```

**Expected Output:**

```
Finding Connected Components:
Component 1: 0 1 2 
Component 2: 3 4 
Component 3: 5 6 
Total Connected Components: 3

Number of components: 3
```

## Advanced Applications

### 1. Component Sizes

```cpp
vector<int> getComponentSizes() {
    fill(used.begin(), used.end(), false);
    vector<int> sizes;
    
    for (int v = 0; v < n; ++v) {
        if (!used[v]) {
            comp.clear();
            dfs(v);
            sizes.push_back(comp.size());
        }
    }
    return sizes;
}
```

### 2. Component Membership

```cpp
vector<int> getComponentIds() {
    fill(used.begin(), used.end(), false);
    vector<int> componentId(n, -1);
    int currentId = 0;
    
    for (int v = 0; v < n; ++v) {
        if (!used[v]) {
            comp.clear();
            dfs(v);
            
            for (int u : comp) {
                componentId[u] = currentId;
            }
            currentId++;
        }
    }
    return componentId;
}
```

### 3. Largest Component

```cpp
vector<int> getLargestComponent() {
    fill(used.begin(), used.end(), false);
    vector<int> largestComp;
    int maxSize = 0;
    
    for (int v = 0; v < n; ++v) {
        if (!used[v]) {
            comp.clear();
            dfs(v);
            
            if (comp.size() > maxSize) {
                maxSize = comp.size();
                largestComp = comp;
            }
        }
    }
    return largestComp;
}
```

## Complexity Analysis

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|**Finding all components**|O(V + E)|O(V)|
|**Counting components**|O(V + E)|O(V)|
|**Component sizes**|O(V + E)|O(V)|
|**Component membership**|O(V + E)|O(V)|

Where:

- V = Number of vertices
- E = Number of edges

## Common Use Cases

### 1. Network Analysis

- Finding isolated groups in social networks
- Identifying disconnected parts of computer networks
- Analyzing communication patterns

### 2. Image Processing

- Connected component labeling in binary images
- Object detection and segmentation
- Pixel region analysis

### 3. Game Development

- Finding reachable areas in game maps
- Identifying isolated regions
- Pathfinding optimization

### 4. Data Analysis

- Clustering related data points
- Finding groups in datasets
- Graph-based data mining

## Comparison: DFS vs BFS for Connected Components

|Aspect|DFS|BFS|
|---|---|---|
|**Memory**|O(depth) stack space|O(width) queue space|
|**Implementation**|Simpler (recursive)|Needs queue|
|**Stack Overflow**|Possible for deep graphs|No risk|
|**Order of traversal**|Depth-first|Level-wise|
|**Performance**|Generally faster|Slightly slower|

## Common Interview Problems

### 1. Number of Islands (2D Grid)

```cpp
// Count connected components in a 2D binary grid
int numIslands(vector<vector<char>>& grid) {
    int count = 0;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (grid[i][j] == '1') {
                dfsGrid(grid, i, j);  // Mark entire island
                count++;
            }
        }
    }
    return count;
}
```

### 2. Friend Circles

```cpp
// Count connected components in friendship matrix
int findCircleNum(vector<vector<int>>& M) {
    int n = M.size();
    vector<bool> visited(n, false);
    int count = 0;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(M, i, visited);
            count++;
        }
    }
    return count;
}
```

## Key Takeaways

1. **Connected components partition an undirected graph** into disjoint subsets
2. **DFS/BFS can be used** to find all connected components in O(V + E) time
3. **Multiple traversals** are needed - one for each component
4. **Applications are numerous** - from network analysis to image processing
5. **Both recursive and iterative** implementations are possible
6. **Choose DFS for simplicity**, BFS for level-wise traversal needs

## Common Mistakes to Avoid

- Forgetting to reset the visited array between different problems
- Not handling the case when the graph has no edges (all single-node components)
- Confusing connected components with strongly connected components (directed graphs)
- Not considering 0-based vs 1-based indexing in problems
- Assuming the graph is connected when it might not be

## Practice Problems

1. **LeetCode 200**: Number of Islands
2. **LeetCode 547**: Friend Circles
3. **LeetCode 323**: Number of Connected Components in Undirected Graph
4. **GFG**: Connected Components in an undirected graph
5. **HackerRank**: Connected Cells in a Grid
# G-5: Breadth-First Search (BFS) | Graph Traversal Technique

## üìö Video Information

- **Video Title**: G-5. Breadth-First Search (BFS) | C++ and Java | Traversal Technique in Graphs
- **Playlist**: Striver's A2Z DSA Course - Graph Series
- **Video URL**: https://www.youtube.com/watch?v=-tgVpUgsQ5k&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn
- **Series**: Graph Algorithms
- **Prerequisites**: Basic Graph Representation, Queue Data Structure

---

## üéØ Learning Objectives

- [ ] Understand BFS traversal technique and its working principle
- [ ] Learn to implement BFS using queue data structure
- [ ] Analyze time and space complexity of BFS
- [ ] Apply BFS for level-order traversal of graphs
- [ ] Understand when to use BFS vs other traversal techniques

---

## üìñ Key Concepts

### Core Topic: Breadth-First Search (BFS)

#### Definition

Breadth First Search is a recursive algorithm for searching all the vertices of a graph or tree data structure. BFS explores nodes level by level, visiting all neighbors of a node before moving to the next level.

#### Why is BFS Important?

- **Level-wise exploration**: Explores graph level by level from source
- **Shortest path**: In unweighted graphs, BFS finds shortest path
- **Connected components**: Can detect connected components
- **Cycle detection**: Can detect cycles in graphs
- **Applications**: Web crawling, social networking, GPS navigation

#### Prerequisites

- Understanding of Graph representation (Adjacency List/Matrix)
- Queue data structure and its operations
- Basic graph terminology (vertices, edges, neighbors)

---

## üîç Detailed Notes

### Section 1: BFS Algorithm Overview

#### Core Principle

BFS uses the **"First In, First Out" (FIFO)** principle using a Queue data structure. It explores:

1. **Current level**: All nodes at current distance
2. **Next level**: All nodes at distance + 1
3. **Progressive exploration**: Level by level expansion

#### Key Components

- **Queue**: Stores nodes to be visited next
- **Visited Array**: Tracks already visited nodes
- **Traversal Order**: Level-wise node exploration

#### BFS vs DFS Comparison

|Aspect|BFS|DFS|
|---|---|---|
|Data Structure|Queue|Stack/Recursion|
|Exploration|Level-wise|Depth-wise|
|Memory|O(V)|O(V)|
|Shortest Path|Yes (unweighted)|No|

---

### Section 2: BFS Algorithm Implementation

#### Step-by-Step Process

1. **Initialize**: Create queue and visited array
2. **Start**: Add source node to queue, mark as visited
3. **Process**: While queue is not empty:
    - Dequeue a node and process it
    - Add all unvisited neighbors to queue
    - Mark neighbors as visited
4. **Complete**: Continue until queue is empty

#### Pseudocode

```
function BFS(graph, source):
    queue = new Queue()
    visited = new boolean array of size V
    bfsTraversal = new list
    
    queue.push(source)
    visited[source] = true
    
    while queue is not empty:
        node = queue.pop()
        bfsTraversal.add(node)
        
        for each neighbor of node:
            if not visited[neighbor]:
                visited[neighbor] = true
                queue.push(neighbor)
    
    return bfsTraversal
```

#### Mathematical Analysis

- **Time Complexity**: O(V + E)
    - V: Number of vertices (each visited once)
    - E: Number of edges (each explored once)
- **Space Complexity**: O(V)
    - Queue: O(V) in worst case
    - Visited array: O(V)
    - Recursion stack: O(V) for disconnected components

---

### Section 3: Code Implementation

#### C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        vector<int> bfs;
        vector<bool> visited(V, false);
        queue<int> q;
        
        // Start from node 0
        q.push(0);
        visited[0] = true;
        
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            
            // Traverse all neighbors
            for (int neighbor : adj[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        
        return bfs;
    }
};

// Test implementation
int main() {
    int V = 5; // Number of vertices
    vector<int> adj[V];
    
    // Creating adjacency list
    adj[0].push_back(1);
    adj[0].push_back(2);
    adj[1].push_back(3);
    adj[1].push_back(4);
    adj[2].push_back(4);
    
    Solution obj;
    vector<int> result = obj.bfsOfGraph(V, adj);
    
    cout << "BFS Traversal: ";
    for (int node : result) {
        cout << node << " ";
    }
    
    return 0;
}
```

#### Java Implementation

```java
import java.util.*;

class Solution {
    public ArrayList<Integer> bfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> bfs = new ArrayList<>();
        boolean[] visited = new boolean[V];
        Queue<Integer> queue = new LinkedList<>();
        
        // Start from node 0
        queue.add(0);
        visited[0] = true;
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            bfs.add(node);
            
            // Traverse all neighbors
            for (int neighbor : adj.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.add(neighbor);
                }
            }
        }
        
        return bfs;
    }
}

// Test class
public class BFSGraph {
    public static void main(String[] args) {
        int V = 5;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        
        // Initialize adjacency list
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        
        // Add edges
        adj.get(0).add(1);
        adj.get(0).add(2);
        adj.get(1).add(3);
        adj.get(1).add(4);
        adj.get(2).add(4);
        
        Solution obj = new Solution();
        ArrayList<Integer> result = obj.bfsOfGraph(V, adj);
        
        System.out.println("BFS Traversal: " + result);
    }
}
```

---

## üìä Examples and Dry Run

### Example 1: Simple Connected Graph

**Graph Structure:**

```
    0
   / \
  1   2
 /|   |
3 4   4
```

**Adjacency List:**

- 0: [1, 2]
- 1: [0, 3, 4]
- 2: [0, 4]
- 3: [1]
- 4: [1, 2]

**BFS Traversal from node 0:**

|Step|Queue|Current|Visited|BFS Result|Action|
|---|---|---|---|---|---|
|1|[0]|-|[T,F,F,F,F]|[]|Start with 0|
|2|[1,2]|0|[T,T,T,F,F]|[0]|Process 0, add neighbors 1,2|
|3|[2,3,4]|1|[T,T,T,T,T]|[0,1]|Process 1, add neighbors 3,4|
|4|[3,4]|2|[T,T,T,T,T]|[0,1,2]|Process 2, no new neighbors|
|5|[4]|3|[T,T,T,T,T]|[0,1,2,3]|Process 3, no new neighbors|
|6|[]|4|[T,T,T,T,T]|[0,1,2,3,4]|Process 4, queue empty|

**Final BFS Traversal**: [0, 1, 2, 3, 4]

### Example 2: Disconnected Graph

For disconnected graphs, we need to handle multiple components:

```cpp
vector<int> bfsDisconnected(int V, vector<int> adj[]) {
    vector<int> bfs;
    vector<bool> visited(V, false);
    
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            queue<int> q;
            q.push(i);
            visited[i] = true;
            
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                bfs.push_back(node);
                
                for (int neighbor : adj[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
    }
    return bfs;
}
```

---

## üß† Problem Solving Patterns

### Pattern Recognition

**When to Use BFS:**

- Finding shortest path in unweighted graphs
- Level-order traversal required
- Finding connected components
- Cycle detection in undirected graphs
- Finding if path exists between two nodes

### BFS Applications

#### 1. Shortest Path in Unweighted Graph

```cpp
int shortestPath(vector<int> adj[], int src, int dest, int V) {
    vector<int> distance(V, -1);
    queue<int> q;
    
    q.push(src);
    distance[src] = 0;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        if (node == dest) return distance[dest];
        
        for (int neighbor : adj[node]) {
            if (distance[neighbor] == -1) {
                distance[neighbor] = distance[node] + 1;
                q.push(neighbor);
            }
        }
    }
    return -1; // No path found
}
```

#### 2. Check if Graph is Bipartite

```cpp
bool isBipartite(vector<int> adj[], int V) {
    vector<int> color(V, -1);
    
    for (int i = 0; i < V; i++) {
        if (color[i] == -1) {
            queue<int> q;
            q.push(i);
            color[i] = 0;
            
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                
                for (int neighbor : adj[node]) {
                    if (color[neighbor] == -1) {
                        color[neighbor] = 1 - color[node];
                        q.push(neighbor);
                    } else if (color[neighbor] == color[node]) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
```

---

## ‚ö° Optimization Techniques

### Space Optimization

- **In-place marking**: Use input array for visited marking if possible
- **Bitwise operations**: Use bitset for visited array when V is large
- **Level-by-level**: Process one level at a time to save space

### Time Optimization

- **Early termination**: Stop when target is found
- **Bidirectional BFS**: Search from both ends
- **Pruning**: Skip nodes that don't lead to solution

### Trade-offs

- **Memory vs Time**: BFS uses more memory than DFS but finds shortest path
- **Iterative vs Recursive**: BFS is naturally iterative, avoiding stack overflow

---

## üé® Visual Representation

### BFS Traversal Tree

```
Level 0:     0
            / \
Level 1:   1   2
          /|   |
Level 2: 3 4   4
```

### Queue State Changes

```
Initial: Queue = [0], Visited = {0}
Step 1:  Queue = [1,2], Visited = {0,1,2}
Step 2:  Queue = [2,3,4], Visited = {0,1,2,3,4}
Step 3:  Queue = [3,4], Visited = {0,1,2,3,4}
Step 4:  Queue = [4], Visited = {0,1,2,3,4}
Step 5:  Queue = [], Visited = {0,1,2,3,4}
```

---

## üîó Related Topics

### Previous Topics

- [[G-1: Graph Representation]] - Adjacency List/Matrix
- [[G-2: Connected Components]] - Graph connectivity
- [[Queue Data Structure]] - FIFO principle

### Next Topics

- [[G-6: Depth-First Search (DFS)]] - Alternative traversal
- [[G-7: Detect Cycle using BFS]] - Cycle detection
- [[G-8: Shortest Path Algorithms]] - Dijkstra, Bellman-Ford

### Connected Concepts

- **Data Structures**: Queue, Graph, Array
- **Algorithms**: Level-order traversal, Shortest path
- **Applications**: Social networks, Web crawling, GPS systems

---

## üí° Tips and Tricks

### Common Mistakes

- **Forgetting to mark as visited**: Always mark node as visited when adding to queue
- **Wrong queue operations**: Use `push/pop` (not `push/front`) for proper FIFO
- **Index bounds**: Check array bounds when accessing neighbors
- **Disconnected graphs**: Handle multiple components separately

### Best Practices

- **Initialize properly**: Always initialize visited array and queue
- **Handle edge cases**: Empty graph, single node, disconnected components
- **Use appropriate data types**: `vector<bool>` for visited, `queue<int>` for BFS

### Memory Aids

- **"Queue for BFS"**: Remember BFS uses Queue (FIFO)
- **"Level by Level"**: BFS explores level-wise like tree levels
- **"Breadth then Depth"**: Wide exploration before deep exploration

---

## üìù Practice Problems

### Easy Level

- [ ] [BFS of Graph](https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1) - GeeksforGeeks
- [ ] [Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) - LeetCode 102

### Medium Level

- [ ] [Shortest Path in Unweighted Graph](https://practice.geeksforgeeks.org/problems/shortest-path-in-unweighted-graph/1) - GeeksforGeeks
- [ ] [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) - LeetCode 994
- [ ] [Word Ladder](https://leetcode.com/problems/word-ladder/) - LeetCode 127

### Hard Level

- [ ] [Word Ladder II](https://leetcode.com/problems/word-ladder-ii/) - LeetCode 126
- [ ] [Minimum Steps to Reach Target](https://practice.geeksforgeeks.org/problems/minimum-step-to-reach-target-knight/) - GeeksforGeeks

---

## üîÑ Review Schedule

### First Review

- **Date**: [1 day after learning]
- **Status**: [ ] Completed
- **Focus**: Basic algorithm and implementation

### Second Review

- **Date**: [3 days after first review]
- **Status**: [ ] Completed
- **Focus**: Applications and problem-solving patterns

### Third Review

- **Date**: [1 week after second review]
- **Status**: [ ] Completed
- **Focus**: Advanced applications and optimization techniques

---

## ü§î Key Questions to Master

### Conceptual Understanding

- [ ] **Q1**: Why does BFS give shortest path in unweighted graphs? **A1**: BFS explores nodes level by level, ensuring we reach destination with minimum edges first.
    
- [ ] **Q2**: What's the difference between BFS and level-order traversal? **A2**: They're essentially the same - BFS naturally performs level-order traversal.
    

### Implementation Details

- [ ] **Q3**: Why mark visited when adding to queue, not when processing? **A3**: Prevents same node from being added multiple times to queue.
    
- [ ] **Q4**: How to handle disconnected components in BFS? **A4**: Iterate through all nodes, start BFS from unvisited nodes.
    

---

## üèÜ Mastery Checklist

- [ ] Can explain BFS algorithm clearly with example
- [ ] Can implement BFS from memory in both C++ and Java
- [ ] Can trace through BFS execution step by step
- [ ] Can identify when to use BFS vs other algorithms
- [ ] Can modify BFS for specific applications (shortest path, bipartite check)
- [ ] Can handle both connected and disconnected graphs
- [ ] Can analyze time and space complexity correctly
- [ ] Have solved at least 5 BFS-related problems successfully

---

## üìà Progress Tracking

**Understanding Level**: Beginner ‚Üí Intermediate ‚Üí Advanced **Confidence Score**: ___/10 **Date Started**: [Add date] **Date Mastered**: [Add when confident]

**Weak Areas to Focus**:

- [ ] Queue operations and FIFO principle
- [ ] Handling disconnected components
- [ ] BFS applications and variations
- [ ] Time/space complexity analysis

---

## Tags

#DSA #Striver #BFS #GraphTraversal #Queue #ShortestPath #LevelOrder #GraphAlgorithms #CodingInterview #FAANG #TakeUForward
# G-6: Depth-First Search (DFS) | Graph Traversal Technique

## üìö Video Information

- **Video Title**: G-6. Depth-First Search (DFS) | C++ and Java | Graph Traversal Technique
- **Playlist**: Striver's A2Z DSA Course - Graph Series
- **Video URL**: https://www.youtube.com/watch?v=Qzf1a--rhp8&list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&index=6
- **Series**: Graph Algorithms
- **Prerequisites**: Basic Graph Representation, Recursion, Stack Data Structure

---

## üéØ Learning Objectives

- [ ] Understand DFS traversal technique and its working principle
- [ ] Learn to implement DFS using recursion and iterative approach
- [ ] Analyze time and space complexity of DFS
- [ ] Apply DFS for connected components and cycle detection
- [ ] Compare DFS with BFS and understand when to use each

---

## üìñ Key Concepts

### Core Topic: Depth-First Search (DFS)

#### Definition

Depth-First Search is a recursive algorithm for traversing or searching tree or graph data structures. DFS starts at a root node and explores as far as possible along each branch before backtracking. It follows the **"Last In, First Out" (LIFO)** principle.

#### Why is DFS Important?

- **Deep exploration**: Goes as deep as possible before backtracking
- **Memory efficient**: Uses less memory than BFS in most cases
- **Cycle detection**: Excellent for detecting cycles in graphs
- **Connected components**: Can find all connected components
- **Topological sorting**: Foundation for topological sort algorithms
- **Path finding**: Can find paths between nodes (though not shortest)

#### Prerequisites

- Understanding of Graph representation (Adjacency List/Matrix)
- Recursion and function call stack
- Stack data structure (for iterative implementation)
- Basic graph terminology (vertices, edges, neighbors)

---

## üîç Detailed Notes

### Section 1: DFS Algorithm Overview

#### Core Principle

DFS uses the **"Last In, First Out" (LIFO)** principle using either:

1. **Recursion**: Uses implicit system stack
2. **Explicit Stack**: Manual stack implementation

#### Key Components

- **Visited Array**: Tracks already visited nodes
- **Recursion Stack/Explicit Stack**: Manages the traversal path
- **Backtracking**: Returns to previous node when no unvisited neighbors exist

#### DFS vs BFS Comparison

|Aspect|DFS|BFS|
|---|---|---|
|Data Structure|Stack/Recursion|Queue|
|Exploration|Depth-wise|Level-wise|
|Memory Usage|O(H) height|O(W) width|
|Shortest Path|No|Yes (unweighted)|
|Implementation|Recursive/Iterative|Iterative|

---

### Section 2: DFS Algorithm Implementation

#### Step-by-Step Process

1. **Initialize**: Create visited array
2. **Start**: Mark source node as visited
3. **Process**: Add current node to result
4. **Recurse**: For each unvisited neighbor, recursively call DFS
5. **Backtrack**: Return when no unvisited neighbors exist
6. **Complete**: Continue until all reachable nodes are visited

#### Pseudocode - Recursive Approach

```
function DFS(node, adj, visited, result):
    visited[node] = true
    result.add(node)
    
    for each neighbor in adj[node]:
        if not visited[neighbor]:
            DFS(neighbor, adj, visited, result)
```

#### Pseudocode - Iterative Approach

```
function DFS_Iterative(source, adj, V):
    stack = new Stack()
    visited = new boolean array of size V
    result = new list
    
    stack.push(source)
    
    while stack is not empty:
        node = stack.pop()
        
        if not visited[node]:
            visited[node] = true
            result.add(node)
            
            for each neighbor in adj[node] (in reverse order):
                if not visited[neighbor]:
                    stack.push(neighbor)
    
    return result
```

#### Mathematical Analysis

- **Time Complexity**: O(V + E)
    - V: Number of vertices (each visited once)
    - E: Number of edges (each explored once)
- **Space Complexity**:
    - Recursive: O(V) for recursion stack in worst case
    - Iterative: O(V) for explicit stack
    - Both: O(V) for visited array

---

### Section 3: Code Implementation

#### C++ Implementation - Recursive

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
private:
    void dfs(int node, vector<int> adj[], vector<bool> &visited, vector<int> &result) {
        visited[node] = true;
        result.push_back(node);
        
        // Traverse all neighbors
        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited, result);
            }
        }
    }
    
public:
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        vector<int> dfs_result;
        vector<bool> visited(V, false);
        
        // Start DFS from node 0
        dfs(0, adj, visited, dfs_result);
        
        return dfs_result;
    }
    
    // For disconnected graphs
    vector<int> dfsDisconnected(int V, vector<int> adj[]) {
        vector<int> dfs_result;
        vector<bool> visited(V, false);
        
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited, dfs_result);
            }
        }
        
        return dfs_result;
    }
};

// Test implementation
int main() {
    int V = 5; // Number of vertices
    vector<int> adj[V];
    
    // Creating adjacency list
    adj[0].push_back(2);
    adj[0].push_back(3);
    adj[0].push_back(1);
    adj[1].push_back(0);
    adj[2].push_back(0);
    adj[2].push_back(4);
    adj[3].push_back(0);
    adj[4].push_back(2);
    
    Solution obj;
    vector<int> result = obj.dfsOfGraph(V, adj);
    
    cout << "DFS Traversal: ";
    for (int node : result) {
        cout << node << " ";
    }
    cout << endl;
    
    return 0;
}
```

#### C++ Implementation - Iterative

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> dfsIterative(int V, vector<int> adj[]) {
        vector<int> dfs_result;
        vector<bool> visited(V, false);
        stack<int> st;
        
        st.push(0); // Start from node 0
        
        while (!st.empty()) {
            int node = st.top();
            st.pop();
            
            if (!visited[node]) {
                visited[node] = true;
                dfs_result.push_back(node);
                
                // Add neighbors in reverse order for same traversal as recursive
                for (int i = adj[node].size() - 1; i >= 0; i--) {
                    if (!visited[adj[node][i]]) {
                        st.push(adj[node][i]);
                    }
                }
            }
        }
        
        return dfs_result;
    }
};
```

#### Java Implementation - Recursive

```java
import java.util.*;

class Solution {
    private void dfs(int node, ArrayList<ArrayList<Integer>> adj, 
                     boolean[] visited, ArrayList<Integer> result) {
        visited[node] = true;
        result.add(node);
        
        // Traverse all neighbors
        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited, result);
            }
        }
    }
    
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> dfs_result = new ArrayList<>();
        boolean[] visited = new boolean[V];
        
        // Start DFS from node 0
        dfs(0, adj, visited, dfs_result);
        
        return dfs_result;
    }
    
    // For disconnected graphs
    public ArrayList<Integer> dfsDisconnected(int V, ArrayList<ArrayList<Integer>> adj) {
        ArrayList<Integer> dfs_result = new ArrayList<>();
        boolean[] visited = new boolean[V];
        
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited, dfs_result);
            }
        }
        
        return dfs_result;
    }
}

// Test class
public class DFSGraph {
    public static void main(String[] args) {
        int V = 5;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        
        // Initialize adjacency list
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        
        // Add edges
        adj.get(0).add(2);
        adj.get(0).add(3);
        adj.get(0).add(1);
        adj.get(1).add(0);
        adj.get(2).add(0);
        adj.get(2).add(4);
        adj.get(3).add(0);
        adj.get(4).add(2);
        
        Solution obj = new Solution();
        ArrayList<Integer> result = obj.dfsOfGraph(V, adj);
        
        System.out.println("DFS Traversal: " + result);
    }
}
```

---

## üìä Examples and Dry Run

### Example 1: Connected Graph DFS Traversal

**Graph Structure:**

```
    0
   /|\
  1 2 3
    |
    4
```

**Adjacency List:**

- 0: [2, 3, 1] (order matters for traversal)
- 1: [0]
- 2: [0, 4]
- 3: [0]
- 4: [2]

**DFS Traversal from node 0 (Recursive):**

|Call Stack|Current Node|Visited|DFS Result|Action|
|---|---|---|---|---|
|dfs(0)|0|[T,F,F,F,F]|[0]|Visit 0, check neighbors: 2,3,1|
|dfs(0)‚Üídfs(2)|2|[T,F,T,F,F]|[0,2]|Visit 2, check neighbors: 0,4|
|dfs(0)‚Üídfs(2)‚Üídfs(4)|4|[T,F,T,F,T]|[0,2,4]|Visit 4, check neighbors: 2 (visited)|
|dfs(0)‚Üídfs(2)|2|[T,F,T,F,T]|[0,2,4]|Return from dfs(4), 2 complete|
|dfs(0)|0|[T,F,T,F,T]|[0,2,4]|Return from dfs(2), check next: 3|
|dfs(0)‚Üídfs(3)|3|[T,F,T,T,T]|[0,2,4,3]|Visit 3, check neighbors: 0 (visited)|
|dfs(0)|0|[T,F,T,T,T]|[0,2,4,3]|Return from dfs(3), check next: 1|
|dfs(0)‚Üídfs(1)|1|[T,T,T,T,T]|[0,2,4,3,1]|Visit 1, check neighbors: 0 (visited)|
|-|-|[T,T,T,T,T]|[0,2,4,3,1]|All calls return, DFS complete|

**Final DFS Traversal**: [0, 2, 4, 3, 1]

### Example 2: Disconnected Graph

```
Component 1: 0---1    Component 2: 2---3
```

**Adjacency List:**

- 0: [1]
- 1: [0]
- 2: [3]
- 3: [2]

**DFS for Disconnected Graph:**

```cpp
// First component starting from 0
DFS(0): [0, 1]
// Second component starting from 2
DFS(2): [0, 1, 2, 3]
```

---

## üß† Problem Solving Patterns

### Pattern Recognition

**When to Use DFS:**

- Detecting cycles in graphs
- Finding connected components
- Topological sorting
- Path existence problems
- Backtracking algorithms
- Tree traversals (preorder, inorder, postorder)

### DFS Applications

#### 1. Cycle Detection in Undirected Graph

```cpp
bool hasCycleUndirected(int V, vector<int> adj[]) {
    vector<bool> visited(V, false);
    
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            if (dfsCycleCheck(i, -1, adj, visited)) {
                return true;
            }
        }
    }
    return false;
}

bool dfsCycleCheck(int node, int parent, vector<int> adj[], vector<bool> &visited) {
    visited[node] = true;
    
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            if (dfsCycleCheck(neighbor, node, adj, visited)) {
                return true;
            }
        } else if (neighbor != parent) {
            return true; // Back edge found
        }
    }
    return false;
}
```

#### 2. Connected Components Count

```cpp
int countConnectedComponents(int V, vector<int> adj[]) {
    vector<bool> visited(V, false);
    int components = 0;
    
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            dfs(i, adj, visited);
            components++;
        }
    }
    
    return components;
}

void dfs(int node, vector<int> adj[], vector<bool> &visited) {
    visited[node] = true;
    
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, adj, visited);
        }
    }
}
```

#### 3. Path Existence Between Two Nodes

```cpp
bool hasPath(int V, vector<int> adj[], int source, int destination) {
    vector<bool> visited(V, false);
    return dfsPath(source, destination, adj, visited);
}

bool dfsPath(int node, int dest, vector<int> adj[], vector<bool> &visited) {
    if (node == dest) return true;
    
    visited[node] = true;
    
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            if (dfsPath(neighbor, dest, adj, visited)) {
                return true;
            }
        }
    }
    return false;
}
```

---

## ‚ö° Optimization Techniques

### Space Optimization

- **In-place marking**: Modify input if allowed to save visited array
- **Path compression**: For union-find applications
- **Iterative approach**: When recursion depth is a concern

### Time Optimization

- **Early termination**: Stop when target found
- **Pruning**: Skip branches that can't lead to solution
- **Memoization**: Store results for repeated subproblems

### Avoiding Stack Overflow

```cpp
// Iterative DFS to avoid recursion stack overflow
vector<int> dfsIterativeSafe(int V, vector<int> adj[]) {
    vector<int> result;
    vector<bool> visited(V, false);
    stack<int> st;
    
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            st.push(i);
            
            while (!st.empty()) {
                int node = st.top();
                st.pop();
                
                if (!visited[node]) {
                    visited[node] = true;
                    result.push_back(node);
                    
                    for (int j = adj[node].size() - 1; j >= 0; j--) {
                        if (!visited[adj[node][j]]) {
                            st.push(adj[node][j]);
                        }
                    }
                }
            }
        }
    }
    return result;
}
```

---

## üé® Visual Representation

### DFS Traversal Tree

```
Original Graph:    DFS Tree (from 0):
    0                   0
   /|\                 /|\
  1 2 3               2 3 1
    |                 |
    4                 4
```

### Recursion Stack Visualization

```
Call Stack Growth:          Call Stack Shrink:
dfs(0)                     dfs(0)
dfs(0) ‚Üí dfs(2)           dfs(0) ‚Üí dfs(2)
dfs(0) ‚Üí dfs(2) ‚Üí dfs(4)  dfs(0)
                          dfs(0) ‚Üí dfs(3)
                          dfs(0)
                          dfs(0) ‚Üí dfs(1)
                          dfs(0)
                          [empty]
```

---

## üîó Related Topics

### Previous Topics

- [[G-5: Breadth-First Search (BFS)]] - Alternative traversal method
- [[G-1: Graph Representation]] - Adjacency List/Matrix
- [[Recursion Fundamentals]] - Core concept for DFS

### Next Topics

- [[G-7: Detect Cycle using DFS]] - Cycle detection applications
- [[G-8: Bipartite Graph Check]] - Graph coloring with DFS
- [[G-9: Topological Sort]] - DFS-based ordering

### Connected Concepts

- **Data Structures**: Stack, Graph, Recursion
- **Algorithms**: Backtracking, Tree traversals
- **Applications**: Maze solving, Component analysis

---

## üí° Tips and Tricks

### Common Mistakes

- **Infinite recursion**: Forgetting to mark nodes as visited
- **Stack overflow**: Too deep recursion on large graphs
- **Wrong base case**: Not handling leaf nodes properly
- **Modifying during iteration**: Changing adjacency list while traversing

### Best Practices

- **Always mark visited**: Mark node as visited before processing
- **Handle disconnected components**: Loop through all nodes
- **Use appropriate approach**: Recursive for simplicity, iterative for large graphs
- **Consider memory constraints**: Choose between recursive and iterative based on graph size

### Memory Aids

- **"Stack for DFS"**: Remember DFS uses Stack (LIFO) concept
- **"Deep then Back"**: Go deep first, then backtrack
- **"Recursive by Nature"**: DFS is naturally recursive like tree traversal

---

## üìù Practice Problems

### Easy Level

- [ ] [DFS of Graph](https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1) - GeeksforGeeks
- [ ] [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) - LeetCode 144

### Medium Level

- [ ] [Number of Islands](https://leetcode.com/problems/number-of-islands/) - LeetCode 200
- [ ] [Clone Graph](https://leetcode.com/problems/clone-graph/) - LeetCode 133
- [ ] [Path Sum II](https://leetcode.com/problems/path-sum-ii/) - LeetCode 113

### Hard Level

- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/) - LeetCode 212
- [ ] [Longest Increasing Path in Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/) - LeetCode 329

---

## üîÑ Review Schedule

### First Review

- **Date**: [1 day after learning]
- **Status**: [ ] Completed
- **Focus**: Recursive implementation and basic traversal

### Second Review

- **Date**: [3 days after first review]
- **Status**: [ ] Completed
- **Focus**: Iterative implementation and applications

### Third Review

- **Date**: [1 week after second review]
- **Status**: [ ] Completed
- **Focus**: Advanced applications and optimization techniques

---

## ü§î Key Questions to Master

### Conceptual Understanding

- [ ] **Q1**: What's the main difference between DFS and BFS traversal order? **A1**: DFS goes deep along one path before exploring other paths, BFS explores level by level.
    
- [ ] **Q2**: Why doesn't DFS guarantee shortest path in unweighted graphs? **A2**: DFS explores depth-first, may find a longer path before finding the shortest one.
    

### Implementation Details

- [ ] **Q3**: When to use recursive vs iterative DFS? **A3**: Recursive for simplicity and readability, iterative for very large graphs to avoid stack overflow.
    
- [ ] **Q4**: How to handle disconnected components in DFS? **A4**: Loop through all vertices and start DFS from each unvisited vertex.
    

### Application Knowledge

- [ ] **Q5**: How does DFS detect cycles in undirected graphs? **A5**: If we encounter a visited vertex that is not the parent of current vertex, there's a cycle.

---

## üèÜ Mastery Checklist

- [ ] Can explain DFS algorithm with recursion and stack concepts
- [ ] Can implement both recursive and iterative DFS from memory
- [ ] Can trace through DFS execution step by step with call stack
- [ ] Can identify when DFS is better than BFS for specific problems
- [ ] Can modify DFS for cycle detection, connected components
- [ ] Can handle both connected and disconnected graphs
- [ ] Can choose between recursive/iterative based on constraints
- [ ] Have solved at least 5 DFS-related problems successfully

---

## üìà Progress Tracking

**Understanding Level**: Beginner ‚Üí Intermediate ‚Üí Advanced **Confidence Score**: ___/10 **Date Started**: [Add date] **Date Mastered**: [Add when confident]

**Areas of Focus**:

- [ ] Recursion and call stack understanding
- [ ] Iterative implementation with explicit stack
- [ ] DFS applications (cycles, components, paths)
- [ ] Space complexity analysis and optimization

**Weak Areas to Improve**:

- [ ] Stack overflow handling in deep recursions
- [ ] Iterative DFS implementation details
- [ ] Advanced applications and modifications
- [ ] Optimization techniques for large graphs

---

## Tags

#DSA #Striver #DFS #GraphTraversal #Recursion #Stack #CycleDetection #ConnectedComponents #DepthFirst #GraphAlgorithms #CodingInterview #FAANG #TakeUForward